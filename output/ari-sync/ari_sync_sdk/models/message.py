# coding: utf-8

"""
    Asterisk ARI

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 6.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from importlib import import_module
from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ari_sync_sdk.models.application_move_failed import ApplicationMoveFailed
    from ari_sync_sdk.models.application_replaced import ApplicationReplaced
    from ari_sync_sdk.models.bridge_attended_transfer import BridgeAttendedTransfer
    from ari_sync_sdk.models.bridge_blind_transfer import BridgeBlindTransfer
    from ari_sync_sdk.models.bridge_created import BridgeCreated
    from ari_sync_sdk.models.bridge_destroyed import BridgeDestroyed
    from ari_sync_sdk.models.bridge_merged import BridgeMerged
    from ari_sync_sdk.models.bridge_video_source_changed import BridgeVideoSourceChanged
    from ari_sync_sdk.models.channel_caller_id import ChannelCallerId
    from ari_sync_sdk.models.channel_connected_line import ChannelConnectedLine
    from ari_sync_sdk.models.channel_created import ChannelCreated
    from ari_sync_sdk.models.channel_destroyed import ChannelDestroyed
    from ari_sync_sdk.models.channel_dialplan import ChannelDialplan
    from ari_sync_sdk.models.channel_dtmf_received import ChannelDtmfReceived
    from ari_sync_sdk.models.channel_entered_bridge import ChannelEnteredBridge
    from ari_sync_sdk.models.channel_hangup_request import ChannelHangupRequest
    from ari_sync_sdk.models.channel_hold import ChannelHold
    from ari_sync_sdk.models.channel_left_bridge import ChannelLeftBridge
    from ari_sync_sdk.models.channel_state_change import ChannelStateChange
    from ari_sync_sdk.models.channel_talking_finished import ChannelTalkingFinished
    from ari_sync_sdk.models.channel_talking_started import ChannelTalkingStarted
    from ari_sync_sdk.models.channel_unhold import ChannelUnhold
    from ari_sync_sdk.models.channel_userevent import ChannelUserevent
    from ari_sync_sdk.models.channel_varset import ChannelVarset
    from ari_sync_sdk.models.contact_status_change import ContactStatusChange
    from ari_sync_sdk.models.device_state_changed import DeviceStateChanged
    from ari_sync_sdk.models.dial import Dial
    from ari_sync_sdk.models.endpoint_state_change import EndpointStateChange
    from ari_sync_sdk.models.event import Event
    from ari_sync_sdk.models.missing_params import MissingParams
    from ari_sync_sdk.models.peer_status_change import PeerStatusChange
    from ari_sync_sdk.models.playback_continuing import PlaybackContinuing
    from ari_sync_sdk.models.playback_finished import PlaybackFinished
    from ari_sync_sdk.models.playback_started import PlaybackStarted
    from ari_sync_sdk.models.recording_failed import RecordingFailed
    from ari_sync_sdk.models.recording_finished import RecordingFinished
    from ari_sync_sdk.models.recording_started import RecordingStarted
    from ari_sync_sdk.models.stasis_end import StasisEnd
    from ari_sync_sdk.models.stasis_start import StasisStart
    from ari_sync_sdk.models.text_message_received import TextMessageReceived

class Message(BaseModel):
    """
    Base type for errors and events
    """ # noqa: E501
    asterisk_id: Optional[StrictStr] = Field(default=None, description="The unique ID for the Asterisk instance that raised this event.")
    type: StrictStr = Field(description="Indicates the type of this message.")
    __properties: ClassVar[List[str]] = ["asterisk_id", "type"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    # JSON field name that stores the object type
    __discriminator_property_name: ClassVar[str] = 'type'

    # discriminator mappings
    __discriminator_value_class_map: ClassVar[Dict[str, str]] = {
        'ApplicationMoveFailed': 'ApplicationMoveFailed','ApplicationReplaced': 'ApplicationReplaced','BridgeAttendedTransfer': 'BridgeAttendedTransfer','BridgeBlindTransfer': 'BridgeBlindTransfer','BridgeCreated': 'BridgeCreated','BridgeDestroyed': 'BridgeDestroyed','BridgeMerged': 'BridgeMerged','BridgeVideoSourceChanged': 'BridgeVideoSourceChanged','ChannelCallerId': 'ChannelCallerId','ChannelConnectedLine': 'ChannelConnectedLine','ChannelCreated': 'ChannelCreated','ChannelDestroyed': 'ChannelDestroyed','ChannelDialplan': 'ChannelDialplan','ChannelDtmfReceived': 'ChannelDtmfReceived','ChannelEnteredBridge': 'ChannelEnteredBridge','ChannelHangupRequest': 'ChannelHangupRequest','ChannelHold': 'ChannelHold','ChannelLeftBridge': 'ChannelLeftBridge','ChannelStateChange': 'ChannelStateChange','ChannelTalkingFinished': 'ChannelTalkingFinished','ChannelTalkingStarted': 'ChannelTalkingStarted','ChannelUnhold': 'ChannelUnhold','ChannelUserevent': 'ChannelUserevent','ChannelVarset': 'ChannelVarset','ContactStatusChange': 'ContactStatusChange','DeviceStateChanged': 'DeviceStateChanged','Dial': 'Dial','EndpointStateChange': 'EndpointStateChange','Event': 'Event','MissingParams': 'MissingParams','PeerStatusChange': 'PeerStatusChange','PlaybackContinuing': 'PlaybackContinuing','PlaybackFinished': 'PlaybackFinished','PlaybackStarted': 'PlaybackStarted','RecordingFailed': 'RecordingFailed','RecordingFinished': 'RecordingFinished','RecordingStarted': 'RecordingStarted','StasisEnd': 'StasisEnd','StasisStart': 'StasisStart','TextMessageReceived': 'TextMessageReceived'
    }

    @classmethod
    def get_discriminator_value(cls, obj: Dict[str, Any]) -> Optional[str]:
        """Returns the discriminator value (object type) of the data"""
        discriminator_value = obj[cls.__discriminator_property_name]
        if discriminator_value:
            return cls.__discriminator_value_class_map.get(discriminator_value)
        else:
            return None

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Union[ApplicationMoveFailed, ApplicationReplaced, BridgeAttendedTransfer, BridgeBlindTransfer, BridgeCreated, BridgeDestroyed, BridgeMerged, BridgeVideoSourceChanged, ChannelCallerId, ChannelConnectedLine, ChannelCreated, ChannelDestroyed, ChannelDialplan, ChannelDtmfReceived, ChannelEnteredBridge, ChannelHangupRequest, ChannelHold, ChannelLeftBridge, ChannelStateChange, ChannelTalkingFinished, ChannelTalkingStarted, ChannelUnhold, ChannelUserevent, ChannelVarset, ContactStatusChange, DeviceStateChanged, Dial, EndpointStateChange, Event, MissingParams, PeerStatusChange, PlaybackContinuing, PlaybackFinished, PlaybackStarted, RecordingFailed, RecordingFinished, RecordingStarted, StasisEnd, StasisStart, TextMessageReceived]]:
        """Create an instance of Message from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict[str, Any]) -> Optional[Union[ApplicationMoveFailed, ApplicationReplaced, BridgeAttendedTransfer, BridgeBlindTransfer, BridgeCreated, BridgeDestroyed, BridgeMerged, BridgeVideoSourceChanged, ChannelCallerId, ChannelConnectedLine, ChannelCreated, ChannelDestroyed, ChannelDialplan, ChannelDtmfReceived, ChannelEnteredBridge, ChannelHangupRequest, ChannelHold, ChannelLeftBridge, ChannelStateChange, ChannelTalkingFinished, ChannelTalkingStarted, ChannelUnhold, ChannelUserevent, ChannelVarset, ContactStatusChange, DeviceStateChanged, Dial, EndpointStateChange, Event, MissingParams, PeerStatusChange, PlaybackContinuing, PlaybackFinished, PlaybackStarted, RecordingFailed, RecordingFinished, RecordingStarted, StasisEnd, StasisStart, TextMessageReceived]]:
        """Create an instance of Message from a dict"""
        # look up the object type based on discriminator mapping
        object_type = cls.get_discriminator_value(obj)
        if object_type ==  'ApplicationMoveFailed':
            return import_module("ari_sync_sdk.models.application_move_failed").ApplicationMoveFailed.from_dict(obj)
        if object_type ==  'ApplicationReplaced':
            return import_module("ari_sync_sdk.models.application_replaced").ApplicationReplaced.from_dict(obj)
        if object_type ==  'BridgeAttendedTransfer':
            return import_module("ari_sync_sdk.models.bridge_attended_transfer").BridgeAttendedTransfer.from_dict(obj)
        if object_type ==  'BridgeBlindTransfer':
            return import_module("ari_sync_sdk.models.bridge_blind_transfer").BridgeBlindTransfer.from_dict(obj)
        if object_type ==  'BridgeCreated':
            return import_module("ari_sync_sdk.models.bridge_created").BridgeCreated.from_dict(obj)
        if object_type ==  'BridgeDestroyed':
            return import_module("ari_sync_sdk.models.bridge_destroyed").BridgeDestroyed.from_dict(obj)
        if object_type ==  'BridgeMerged':
            return import_module("ari_sync_sdk.models.bridge_merged").BridgeMerged.from_dict(obj)
        if object_type ==  'BridgeVideoSourceChanged':
            return import_module("ari_sync_sdk.models.bridge_video_source_changed").BridgeVideoSourceChanged.from_dict(obj)
        if object_type ==  'ChannelCallerId':
            return import_module("ari_sync_sdk.models.channel_caller_id").ChannelCallerId.from_dict(obj)
        if object_type ==  'ChannelConnectedLine':
            return import_module("ari_sync_sdk.models.channel_connected_line").ChannelConnectedLine.from_dict(obj)
        if object_type ==  'ChannelCreated':
            return import_module("ari_sync_sdk.models.channel_created").ChannelCreated.from_dict(obj)
        if object_type ==  'ChannelDestroyed':
            return import_module("ari_sync_sdk.models.channel_destroyed").ChannelDestroyed.from_dict(obj)
        if object_type ==  'ChannelDialplan':
            return import_module("ari_sync_sdk.models.channel_dialplan").ChannelDialplan.from_dict(obj)
        if object_type ==  'ChannelDtmfReceived':
            return import_module("ari_sync_sdk.models.channel_dtmf_received").ChannelDtmfReceived.from_dict(obj)
        if object_type ==  'ChannelEnteredBridge':
            return import_module("ari_sync_sdk.models.channel_entered_bridge").ChannelEnteredBridge.from_dict(obj)
        if object_type ==  'ChannelHangupRequest':
            return import_module("ari_sync_sdk.models.channel_hangup_request").ChannelHangupRequest.from_dict(obj)
        if object_type ==  'ChannelHold':
            return import_module("ari_sync_sdk.models.channel_hold").ChannelHold.from_dict(obj)
        if object_type ==  'ChannelLeftBridge':
            return import_module("ari_sync_sdk.models.channel_left_bridge").ChannelLeftBridge.from_dict(obj)
        if object_type ==  'ChannelStateChange':
            return import_module("ari_sync_sdk.models.channel_state_change").ChannelStateChange.from_dict(obj)
        if object_type ==  'ChannelTalkingFinished':
            return import_module("ari_sync_sdk.models.channel_talking_finished").ChannelTalkingFinished.from_dict(obj)
        if object_type ==  'ChannelTalkingStarted':
            return import_module("ari_sync_sdk.models.channel_talking_started").ChannelTalkingStarted.from_dict(obj)
        if object_type ==  'ChannelUnhold':
            return import_module("ari_sync_sdk.models.channel_unhold").ChannelUnhold.from_dict(obj)
        if object_type ==  'ChannelUserevent':
            return import_module("ari_sync_sdk.models.channel_userevent").ChannelUserevent.from_dict(obj)
        if object_type ==  'ChannelVarset':
            return import_module("ari_sync_sdk.models.channel_varset").ChannelVarset.from_dict(obj)
        if object_type ==  'ContactStatusChange':
            return import_module("ari_sync_sdk.models.contact_status_change").ContactStatusChange.from_dict(obj)
        if object_type ==  'DeviceStateChanged':
            return import_module("ari_sync_sdk.models.device_state_changed").DeviceStateChanged.from_dict(obj)
        if object_type ==  'Dial':
            return import_module("ari_sync_sdk.models.dial").Dial.from_dict(obj)
        if object_type ==  'EndpointStateChange':
            return import_module("ari_sync_sdk.models.endpoint_state_change").EndpointStateChange.from_dict(obj)
        if object_type ==  'Event':
            return import_module("ari_sync_sdk.models.event").Event.from_dict(obj)
        if object_type ==  'MissingParams':
            return import_module("ari_sync_sdk.models.missing_params").MissingParams.from_dict(obj)
        if object_type ==  'PeerStatusChange':
            return import_module("ari_sync_sdk.models.peer_status_change").PeerStatusChange.from_dict(obj)
        if object_type ==  'PlaybackContinuing':
            return import_module("ari_sync_sdk.models.playback_continuing").PlaybackContinuing.from_dict(obj)
        if object_type ==  'PlaybackFinished':
            return import_module("ari_sync_sdk.models.playback_finished").PlaybackFinished.from_dict(obj)
        if object_type ==  'PlaybackStarted':
            return import_module("ari_sync_sdk.models.playback_started").PlaybackStarted.from_dict(obj)
        if object_type ==  'RecordingFailed':
            return import_module("ari_sync_sdk.models.recording_failed").RecordingFailed.from_dict(obj)
        if object_type ==  'RecordingFinished':
            return import_module("ari_sync_sdk.models.recording_finished").RecordingFinished.from_dict(obj)
        if object_type ==  'RecordingStarted':
            return import_module("ari_sync_sdk.models.recording_started").RecordingStarted.from_dict(obj)
        if object_type ==  'StasisEnd':
            return import_module("ari_sync_sdk.models.stasis_end").StasisEnd.from_dict(obj)
        if object_type ==  'StasisStart':
            return import_module("ari_sync_sdk.models.stasis_start").StasisStart.from_dict(obj)
        if object_type ==  'TextMessageReceived':
            return import_module("ari_sync_sdk.models.text_message_received").TextMessageReceived.from_dict(obj)

        raise ValueError("Message failed to lookup discriminator value from " +
                            json.dumps(obj) + ". Discriminator property name: " + cls.__discriminator_property_name +
                            ", mapping: " + json.dumps(cls.__discriminator_value_class_map))


