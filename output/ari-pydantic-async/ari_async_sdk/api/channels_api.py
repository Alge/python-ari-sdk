# coding: utf-8

"""
    Asterisk ARI

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 6.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing import overload, Optional, Union, Awaitable

from typing_extensions import Annotated
from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist

from typing import Any, Dict, List, Optional

from ari_async_sdk.models.channel import Channel
from ari_async_sdk.models.live_recording import LiveRecording
from ari_async_sdk.models.playback import Playback
from ari_async_sdk.models.rt_pstat import RTPstat
from ari_async_sdk.models.variable import Variable

from ari_async_sdk.api_client import ApiClient
from ari_async_sdk.api_response import ApiResponse
from ari_async_sdk.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ChannelsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    async def add_moh(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], moh_class : Annotated[Optional[StrictStr], Field(description="Music on hold class to use")] = None, **kwargs) -> None:  # noqa: E501
        """Play music on hold to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing MOH in this manner will suspend MOH without resuming automatically. If continuing music on hold is desired, the stasis application must reinitiate music on hold.  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param moh_class: Music on hold class to use
        :type moh_class: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the add_moh_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.add_moh_with_http_info(channel_id, moh_class, **kwargs)  # noqa: E501

    @validate_arguments
    async def add_moh_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], moh_class : Annotated[Optional[StrictStr], Field(description="Music on hold class to use")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Play music on hold to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing MOH in this manner will suspend MOH without resuming automatically. If continuing music on hold is desired, the stasis application must reinitiate music on hold.  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param moh_class: Music on hold class to use
        :type moh_class: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'moh_class'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_moh" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('moh_class') is not None:  # noqa: E501
            _query_params.append(('mohClass', _params['moh_class']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/moh', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def answer(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> None:  # noqa: E501
        """Answer a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the answer_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.answer_with_http_info(channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def answer_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Answer a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method answer" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/answer', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def continue_in_dialplan(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], context : Annotated[Optional[StrictStr], Field(description="The context to continue to.")] = None, extension : Annotated[Optional[StrictStr], Field(description="The extension to continue to.")] = None, priority : Annotated[Optional[StrictInt], Field(description="The priority to continue to.")] = None, label : Annotated[Optional[StrictStr], Field(description="The label to continue to - will supersede 'priority' if both are provided.")] = None, **kwargs) -> None:  # noqa: E501
        """Exit application; continue execution in the dialplan.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param context: The context to continue to.
        :type context: str
        :param extension: The extension to continue to.
        :type extension: str
        :param priority: The priority to continue to.
        :type priority: int
        :param label: The label to continue to - will supersede 'priority' if both are provided.
        :type label: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the continue_in_dialplan_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.continue_in_dialplan_with_http_info(channel_id, context, extension, priority, label, **kwargs)  # noqa: E501

    @validate_arguments
    async def continue_in_dialplan_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], context : Annotated[Optional[StrictStr], Field(description="The context to continue to.")] = None, extension : Annotated[Optional[StrictStr], Field(description="The extension to continue to.")] = None, priority : Annotated[Optional[StrictInt], Field(description="The priority to continue to.")] = None, label : Annotated[Optional[StrictStr], Field(description="The label to continue to - will supersede 'priority' if both are provided.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Exit application; continue execution in the dialplan.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param context: The context to continue to.
        :type context: str
        :param extension: The extension to continue to.
        :type extension: str
        :param priority: The priority to continue to.
        :type priority: int
        :param label: The label to continue to - will supersede 'priority' if both are provided.
        :type label: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'context',
            'extension',
            'priority',
            'label'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method continue_in_dialplan" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        if _params.get('extension') is not None:  # noqa: E501
            _query_params.append(('extension', _params['extension']))

        if _params.get('priority') is not None:  # noqa: E501
            _query_params.append(('priority', _params['priority']))

        if _params.get('label') is not None:  # noqa: E501
            _query_params.append(('label', _params['label']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/continue', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def createchannel(self, endpoint : Annotated[StrictStr, Field(..., description="Endpoint for channel communication")], app : Annotated[StrictStr, Field(..., description="Stasis Application to place channel into")], app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.")] = None, channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the channel on creation.")] = None, other_channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the second channel when using local channels.")] = None, originator : Annotated[Optional[StrictStr], Field(description="Unique ID of the calling channel")] = None, formats : Annotated[Optional[StrictStr], Field(description="The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".")] = None, variables : Annotated[Optional[Dict[str, Any]], Field(description="The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }")] = None, **kwargs) -> Channel:  # noqa: E501
        """Create channel.  # noqa: E501


        :param endpoint: Endpoint for channel communication (required)
        :type endpoint: str
        :param app: Stasis Application to place channel into (required)
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: Unique ID of the calling channel
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type variables: object
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the createchannel_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.createchannel_with_http_info(endpoint, app, app_args, channel_id, other_channel_id, originator, formats, variables, **kwargs)  # noqa: E501

    @validate_arguments
    async def createchannel_with_http_info(self, endpoint : Annotated[StrictStr, Field(..., description="Endpoint for channel communication")], app : Annotated[StrictStr, Field(..., description="Stasis Application to place channel into")], app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.")] = None, channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the channel on creation.")] = None, other_channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the second channel when using local channels.")] = None, originator : Annotated[Optional[StrictStr], Field(description="Unique ID of the calling channel")] = None, formats : Annotated[Optional[StrictStr], Field(description="The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".")] = None, variables : Annotated[Optional[Dict[str, Any]], Field(description="The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create channel.  # noqa: E501


        :param endpoint: Endpoint for channel communication (required)
        :type endpoint: str
        :param app: Stasis Application to place channel into (required)
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: Unique ID of the calling channel
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type variables: object
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'endpoint',
            'app',
            'app_args',
            'channel_id',
            'other_channel_id',
            'originator',
            'formats',
            'variables'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method createchannel" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('endpoint') is not None:  # noqa: E501
            _query_params.append(('endpoint', _params['endpoint']))

        if _params.get('app') is not None:  # noqa: E501
            _query_params.append(('app', _params['app']))

        if _params.get('app_args') is not None:  # noqa: E501
            _query_params.append(('appArgs', _params['app_args']))

        if _params.get('channel_id') is not None:  # noqa: E501
            _query_params.append(('channelId', _params['channel_id']))

        if _params.get('other_channel_id') is not None:  # noqa: E501
            _query_params.append(('otherChannelId', _params['other_channel_id']))

        if _params.get('originator') is not None:  # noqa: E501
            _query_params.append(('originator', _params['originator']))

        if _params.get('formats') is not None:  # noqa: E501
            _query_params.append(('formats', _params['formats']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['variables'] is not None:
            _body_params = _params['variables']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Channel",
        }

        return await self.api_client.call_api(
            '/channels/create', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def deletemoh(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> None:  # noqa: E501
        """Stop playing music on hold to a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the deletemoh_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.deletemoh_with_http_info(channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def deletemoh_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stop playing music on hold to a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletemoh" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/moh', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def dial(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], caller : Annotated[Optional[StrictStr], Field(description="Channel ID of caller")] = None, timeout : Annotated[Optional[StrictInt], Field(description="Dial timeout")] = None, **kwargs) -> None:  # noqa: E501
        """Dial a created channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param caller: Channel ID of caller
        :type caller: str
        :param timeout: Dial timeout
        :type timeout: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the dial_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.dial_with_http_info(channel_id, caller, timeout, **kwargs)  # noqa: E501

    @validate_arguments
    async def dial_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], caller : Annotated[Optional[StrictStr], Field(description="Channel ID of caller")] = None, timeout : Annotated[Optional[StrictInt], Field(description="Dial timeout")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Dial a created channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param caller: Channel ID of caller
        :type caller: str
        :param timeout: Dial timeout
        :type timeout: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'caller',
            'timeout'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dial" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('caller') is not None:  # noqa: E501
            _query_params.append(('caller', _params['caller']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/dial', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def external_media(self, app : Annotated[StrictStr, Field(..., description="Stasis Application to place channel into")], external_host : Annotated[StrictStr, Field(..., description="Hostname/ip:port of external host")], format : Annotated[StrictStr, Field(..., description="Format to encode audio in")], channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the channel on creation.")] = None, encapsulation : Annotated[Optional[StrictStr], Field(description="Payload encapsulation protocol")] = None, transport : Annotated[Optional[StrictStr], Field(description="Transport protocol")] = None, connection_type : Annotated[Optional[StrictStr], Field(description="Connection type (client/server)")] = None, direction : Annotated[Optional[StrictStr], Field(description="External media direction")] = None, data : Annotated[Optional[StrictStr], Field(description="An arbitrary data field")] = None, variables : Annotated[Optional[Dict[str, Any]], Field(description="The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }")] = None, **kwargs) -> Channel:  # noqa: E501
        """Start an External Media session.  # noqa: E501

        Create a channel to an External Media source/sink.  # noqa: E501

        :param app: Stasis Application to place channel into (required)
        :type app: str
        :param external_host: Hostname/ip:port of external host (required)
        :type external_host: str
        :param format: Format to encode audio in (required)
        :type format: str
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param encapsulation: Payload encapsulation protocol
        :type encapsulation: str
        :param transport: Transport protocol
        :type transport: str
        :param connection_type: Connection type (client/server)
        :type connection_type: str
        :param direction: External media direction
        :type direction: str
        :param data: An arbitrary data field
        :type data: str
        :param variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type variables: object
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the external_media_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.external_media_with_http_info(app, external_host, format, channel_id, encapsulation, transport, connection_type, direction, data, variables, **kwargs)  # noqa: E501

    @validate_arguments
    async def external_media_with_http_info(self, app : Annotated[StrictStr, Field(..., description="Stasis Application to place channel into")], external_host : Annotated[StrictStr, Field(..., description="Hostname/ip:port of external host")], format : Annotated[StrictStr, Field(..., description="Format to encode audio in")], channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the channel on creation.")] = None, encapsulation : Annotated[Optional[StrictStr], Field(description="Payload encapsulation protocol")] = None, transport : Annotated[Optional[StrictStr], Field(description="Transport protocol")] = None, connection_type : Annotated[Optional[StrictStr], Field(description="Connection type (client/server)")] = None, direction : Annotated[Optional[StrictStr], Field(description="External media direction")] = None, data : Annotated[Optional[StrictStr], Field(description="An arbitrary data field")] = None, variables : Annotated[Optional[Dict[str, Any]], Field(description="The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Start an External Media session.  # noqa: E501

        Create a channel to an External Media source/sink.  # noqa: E501

        :param app: Stasis Application to place channel into (required)
        :type app: str
        :param external_host: Hostname/ip:port of external host (required)
        :type external_host: str
        :param format: Format to encode audio in (required)
        :type format: str
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param encapsulation: Payload encapsulation protocol
        :type encapsulation: str
        :param transport: Transport protocol
        :type transport: str
        :param connection_type: Connection type (client/server)
        :type connection_type: str
        :param direction: External media direction
        :type direction: str
        :param data: An arbitrary data field
        :type data: str
        :param variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type variables: object
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'app',
            'external_host',
            'format',
            'channel_id',
            'encapsulation',
            'transport',
            'connection_type',
            'direction',
            'data',
            'variables'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method external_media" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('channel_id') is not None:  # noqa: E501
            _query_params.append(('channelId', _params['channel_id']))

        if _params.get('app') is not None:  # noqa: E501
            _query_params.append(('app', _params['app']))

        if _params.get('external_host') is not None:  # noqa: E501
            _query_params.append(('external_host', _params['external_host']))

        if _params.get('encapsulation') is not None:  # noqa: E501
            _query_params.append(('encapsulation', _params['encapsulation']))

        if _params.get('transport') is not None:  # noqa: E501
            _query_params.append(('transport', _params['transport']))

        if _params.get('connection_type') is not None:  # noqa: E501
            _query_params.append(('connection_type', _params['connection_type']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        if _params.get('direction') is not None:  # noqa: E501
            _query_params.append(('direction', _params['direction']))

        if _params.get('data') is not None:  # noqa: E501
            _query_params.append(('data', _params['data']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['variables'] is not None:
            _body_params = _params['variables']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Channel",
        }

        return await self.api_client.call_api(
            '/channels/externalMedia', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def get_channel_var(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], variable : Annotated[StrictStr, Field(..., description="The channel variable or function to get")], **kwargs) -> Variable:  # noqa: E501
        """Get the value of a channel variable or function.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param variable: The channel variable or function to get (required)
        :type variable: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Variable
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_channel_var_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_channel_var_with_http_info(channel_id, variable, **kwargs)  # noqa: E501

    @validate_arguments
    async def get_channel_var_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], variable : Annotated[StrictStr, Field(..., description="The channel variable or function to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get the value of a channel variable or function.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param variable: The channel variable or function to get (required)
        :type variable: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Variable, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'variable'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_channel_var" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('variable') is not None:  # noqa: E501
            _query_params.append(('variable', _params['variable']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Variable",
        }

        return await self.api_client.call_api(
            '/channels/{channelId}/variable', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def getchannel(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> Channel:  # noqa: E501
        """Channel details.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the getchannel_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.getchannel_with_http_info(channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def getchannel_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Channel details.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method getchannel" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Channel",
        }

        return await self.api_client.call_api(
            '/channels/{channelId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def hangup(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], reason_code : Annotated[Optional[StrictStr], Field(description="The reason code for hanging up the channel for detail use. Mutually exclusive with 'reason'. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings")] = None, reason : Annotated[Optional[StrictStr], Field(description="Reason for hanging up the channel for simple use. Mutually exclusive with 'reason_code'.")] = None, **kwargs) -> None:  # noqa: E501
        """Delete (i.e. hangup) a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param reason_code: The reason code for hanging up the channel for detail use. Mutually exclusive with 'reason'. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings
        :type reason_code: str
        :param reason: Reason for hanging up the channel for simple use. Mutually exclusive with 'reason_code'.
        :type reason: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the hangup_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.hangup_with_http_info(channel_id, reason_code, reason, **kwargs)  # noqa: E501

    @validate_arguments
    async def hangup_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], reason_code : Annotated[Optional[StrictStr], Field(description="The reason code for hanging up the channel for detail use. Mutually exclusive with 'reason'. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings")] = None, reason : Annotated[Optional[StrictStr], Field(description="Reason for hanging up the channel for simple use. Mutually exclusive with 'reason_code'.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Delete (i.e. hangup) a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param reason_code: The reason code for hanging up the channel for detail use. Mutually exclusive with 'reason'. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings
        :type reason_code: str
        :param reason: Reason for hanging up the channel for simple use. Mutually exclusive with 'reason_code'.
        :type reason: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'reason_code',
            'reason'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hangup" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('reason_code') is not None:  # noqa: E501
            _query_params.append(('reason_code', _params['reason_code']))

        if _params.get('reason') is not None:  # noqa: E501
            _query_params.append(('reason', _params['reason']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def hold(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> None:  # noqa: E501
        """Hold a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the hold_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.hold_with_http_info(channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def hold_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Hold a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hold" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/hold', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def listchannels(self, **kwargs) -> List[Channel]:  # noqa: E501
        """List all active channels in Asterisk.  # noqa: E501


        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Channel]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the listchannels_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.listchannels_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    async def listchannels_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """List all active channels in Asterisk.  # noqa: E501


        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Channel], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method listchannels" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[Channel]",
        }

        return await self.api_client.call_api(
            '/channels', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def move(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], app : Annotated[StrictStr, Field(..., description="The channel will be passed to this Stasis application.")], app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application provided by 'app'.")] = None, **kwargs) -> None:  # noqa: E501
        """Move the channel from one Stasis application to another.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param app: The channel will be passed to this Stasis application. (required)
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'.
        :type app_args: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the move_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.move_with_http_info(channel_id, app, app_args, **kwargs)  # noqa: E501

    @validate_arguments
    async def move_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], app : Annotated[StrictStr, Field(..., description="The channel will be passed to this Stasis application.")], app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application provided by 'app'.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Move the channel from one Stasis application to another.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param app: The channel will be passed to this Stasis application. (required)
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'.
        :type app_args: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'app',
            'app_args'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('app') is not None:  # noqa: E501
            _query_params.append(('app', _params['app']))

        if _params.get('app_args') is not None:  # noqa: E501
            _query_params.append(('appArgs', _params['app_args']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/move', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def mute(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], direction : Annotated[Optional[StrictStr], Field(description="Direction in which to mute audio")] = None, **kwargs) -> None:  # noqa: E501
        """Mute a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param direction: Direction in which to mute audio
        :type direction: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the mute_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.mute_with_http_info(channel_id, direction, **kwargs)  # noqa: E501

    @validate_arguments
    async def mute_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], direction : Annotated[Optional[StrictStr], Field(description="Direction in which to mute audio")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Mute a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param direction: Direction in which to mute audio
        :type direction: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'direction'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mute" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('direction') is not None:  # noqa: E501
            _query_params.append(('direction', _params['direction']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/mute', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def originate(self, endpoint : Annotated[StrictStr, Field(..., description="Endpoint to call.")], extension : Annotated[Optional[StrictStr], Field(description="The extension to dial after the endpoint answers. Mutually exclusive with 'app'.")] = None, context : Annotated[Optional[StrictStr], Field(description="The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.")] = None, priority : Annotated[Optional[StrictInt], Field(description="The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.")] = None, label : Annotated[Optional[StrictStr], Field(description="The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.")] = None, app : Annotated[Optional[StrictStr], Field(description="The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.")] = None, app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.")] = None, caller_id : Annotated[Optional[StrictStr], Field(description="CallerID to use when dialing the endpoint or extension.")] = None, timeout : Annotated[Optional[StrictInt], Field(description="Timeout (in seconds) before giving up dialing, or -1 for no timeout.")] = None, channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the channel on creation.")] = None, other_channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the second channel when using local channels.")] = None, originator : Annotated[Optional[StrictStr], Field(description="The unique id of the channel which is originating this one.")] = None, formats : Annotated[Optional[StrictStr], Field(description="The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".")] = None, variables : Annotated[Optional[Dict[str, Any]], Field(description="The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }")] = None, **kwargs) -> Channel:  # noqa: E501
        """Create a new channel (originate).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501

        :param endpoint: Endpoint to call. (required)
        :type endpoint: str
        :param extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :type extension: str
        :param context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :type context: str
        :param priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :type priority: int
        :param label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :type label: str
        :param app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param caller_id: CallerID to use when dialing the endpoint or extension.
        :type caller_id: str
        :param timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :type timeout: int
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: The unique id of the channel which is originating this one.
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type variables: object
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the originate_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.originate_with_http_info(endpoint, extension, context, priority, label, app, app_args, caller_id, timeout, channel_id, other_channel_id, originator, formats, variables, **kwargs)  # noqa: E501

    @validate_arguments
    async def originate_with_http_info(self, endpoint : Annotated[StrictStr, Field(..., description="Endpoint to call.")], extension : Annotated[Optional[StrictStr], Field(description="The extension to dial after the endpoint answers. Mutually exclusive with 'app'.")] = None, context : Annotated[Optional[StrictStr], Field(description="The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.")] = None, priority : Annotated[Optional[StrictInt], Field(description="The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.")] = None, label : Annotated[Optional[StrictStr], Field(description="The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.")] = None, app : Annotated[Optional[StrictStr], Field(description="The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.")] = None, app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.")] = None, caller_id : Annotated[Optional[StrictStr], Field(description="CallerID to use when dialing the endpoint or extension.")] = None, timeout : Annotated[Optional[StrictInt], Field(description="Timeout (in seconds) before giving up dialing, or -1 for no timeout.")] = None, channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the channel on creation.")] = None, other_channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the second channel when using local channels.")] = None, originator : Annotated[Optional[StrictStr], Field(description="The unique id of the channel which is originating this one.")] = None, formats : Annotated[Optional[StrictStr], Field(description="The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".")] = None, variables : Annotated[Optional[Dict[str, Any]], Field(description="The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a new channel (originate).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501

        :param endpoint: Endpoint to call. (required)
        :type endpoint: str
        :param extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :type extension: str
        :param context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :type context: str
        :param priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :type priority: int
        :param label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :type label: str
        :param app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param caller_id: CallerID to use when dialing the endpoint or extension.
        :type caller_id: str
        :param timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :type timeout: int
        :param channel_id: The unique id to assign the channel on creation.
        :type channel_id: str
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: The unique id of the channel which is originating this one.
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type variables: object
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'endpoint',
            'extension',
            'context',
            'priority',
            'label',
            'app',
            'app_args',
            'caller_id',
            'timeout',
            'channel_id',
            'other_channel_id',
            'originator',
            'formats',
            'variables'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method originate" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('endpoint') is not None:  # noqa: E501
            _query_params.append(('endpoint', _params['endpoint']))

        if _params.get('extension') is not None:  # noqa: E501
            _query_params.append(('extension', _params['extension']))

        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        if _params.get('priority') is not None:  # noqa: E501
            _query_params.append(('priority', _params['priority']))

        if _params.get('label') is not None:  # noqa: E501
            _query_params.append(('label', _params['label']))

        if _params.get('app') is not None:  # noqa: E501
            _query_params.append(('app', _params['app']))

        if _params.get('app_args') is not None:  # noqa: E501
            _query_params.append(('appArgs', _params['app_args']))

        if _params.get('caller_id') is not None:  # noqa: E501
            _query_params.append(('callerId', _params['caller_id']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        if _params.get('channel_id') is not None:  # noqa: E501
            _query_params.append(('channelId', _params['channel_id']))

        if _params.get('other_channel_id') is not None:  # noqa: E501
            _query_params.append(('otherChannelId', _params['other_channel_id']))

        if _params.get('originator') is not None:  # noqa: E501
            _query_params.append(('originator', _params['originator']))

        if _params.get('formats') is not None:  # noqa: E501
            _query_params.append(('formats', _params['formats']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['variables'] is not None:
            _body_params = _params['variables']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Channel",
        }

        return await self.api_client.call_api(
            '/channels', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def originate_with_id(self, channel_id : Annotated[StrictStr, Field(..., description="The unique id to assign the channel on creation.")], endpoint : Annotated[StrictStr, Field(..., description="Endpoint to call.")], extension : Annotated[Optional[StrictStr], Field(description="The extension to dial after the endpoint answers. Mutually exclusive with 'app'.")] = None, context : Annotated[Optional[StrictStr], Field(description="The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.")] = None, priority : Annotated[Optional[StrictInt], Field(description="The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.")] = None, label : Annotated[Optional[StrictStr], Field(description="The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.")] = None, app : Annotated[Optional[StrictStr], Field(description="The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.")] = None, app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.")] = None, caller_id : Annotated[Optional[StrictStr], Field(description="CallerID to use when dialing the endpoint or extension.")] = None, timeout : Annotated[Optional[StrictInt], Field(description="Timeout (in seconds) before giving up dialing, or -1 for no timeout.")] = None, other_channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the second channel when using local channels.")] = None, originator : Annotated[Optional[StrictStr], Field(description="The unique id of the channel which is originating this one.")] = None, formats : Annotated[Optional[StrictStr], Field(description="The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".")] = None, variables : Annotated[Optional[Dict[str, Any]], Field(description="The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }")] = None, **kwargs) -> Channel:  # noqa: E501
        """Create a new channel (originate with id).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501

        :param channel_id: The unique id to assign the channel on creation. (required)
        :type channel_id: str
        :param endpoint: Endpoint to call. (required)
        :type endpoint: str
        :param extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :type extension: str
        :param context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :type context: str
        :param priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :type priority: int
        :param label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :type label: str
        :param app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param caller_id: CallerID to use when dialing the endpoint or extension.
        :type caller_id: str
        :param timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :type timeout: int
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: The unique id of the channel which is originating this one.
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type variables: object
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the originate_with_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.originate_with_id_with_http_info(channel_id, endpoint, extension, context, priority, label, app, app_args, caller_id, timeout, other_channel_id, originator, formats, variables, **kwargs)  # noqa: E501

    @validate_arguments
    async def originate_with_id_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="The unique id to assign the channel on creation.")], endpoint : Annotated[StrictStr, Field(..., description="Endpoint to call.")], extension : Annotated[Optional[StrictStr], Field(description="The extension to dial after the endpoint answers. Mutually exclusive with 'app'.")] = None, context : Annotated[Optional[StrictStr], Field(description="The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.")] = None, priority : Annotated[Optional[StrictInt], Field(description="The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.")] = None, label : Annotated[Optional[StrictStr], Field(description="The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.")] = None, app : Annotated[Optional[StrictStr], Field(description="The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.")] = None, app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.")] = None, caller_id : Annotated[Optional[StrictStr], Field(description="CallerID to use when dialing the endpoint or extension.")] = None, timeout : Annotated[Optional[StrictInt], Field(description="Timeout (in seconds) before giving up dialing, or -1 for no timeout.")] = None, other_channel_id : Annotated[Optional[StrictStr], Field(description="The unique id to assign the second channel when using local channels.")] = None, originator : Annotated[Optional[StrictStr], Field(description="The unique id of the channel which is originating this one.")] = None, formats : Annotated[Optional[StrictStr], Field(description="The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".")] = None, variables : Annotated[Optional[Dict[str, Any]], Field(description="The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a new channel (originate with id).  # noqa: E501

        The new channel is created immediately and a snapshot of it returned. If a Stasis application is provided it will be automatically subscribed to the originated channel for further events and updates.  # noqa: E501

        :param channel_id: The unique id to assign the channel on creation. (required)
        :type channel_id: str
        :param endpoint: Endpoint to call. (required)
        :type endpoint: str
        :param extension: The extension to dial after the endpoint answers. Mutually exclusive with 'app'.
        :type extension: str
        :param context: The context to dial after the endpoint answers. If omitted, uses 'default'. Mutually exclusive with 'app'.
        :type context: str
        :param priority: The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with 'app'.
        :type priority: int
        :param label: The label to dial after the endpoint answers. Will supersede 'priority' if provided. Mutually exclusive with 'app'.
        :type label: str
        :param app: The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app: str
        :param app_args: The application arguments to pass to the Stasis application provided by 'app'. Mutually exclusive with 'context', 'extension', 'priority', and 'label'.
        :type app_args: str
        :param caller_id: CallerID to use when dialing the endpoint or extension.
        :type caller_id: str
        :param timeout: Timeout (in seconds) before giving up dialing, or -1 for no timeout.
        :type timeout: int
        :param other_channel_id: The unique id to assign the second channel when using local channels.
        :type other_channel_id: str
        :param originator: The unique id of the channel which is originating this one.
        :type originator: str
        :param formats: The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".
        :type formats: str
        :param variables: The \"variables\" key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \"endpoint\": \"SIP/Alice\", \"variables\": { \"CALLERID(name)\": \"Alice\" } }
        :type variables: object
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'endpoint',
            'extension',
            'context',
            'priority',
            'label',
            'app',
            'app_args',
            'caller_id',
            'timeout',
            'other_channel_id',
            'originator',
            'formats',
            'variables'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method originate_with_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('endpoint') is not None:  # noqa: E501
            _query_params.append(('endpoint', _params['endpoint']))

        if _params.get('extension') is not None:  # noqa: E501
            _query_params.append(('extension', _params['extension']))

        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        if _params.get('priority') is not None:  # noqa: E501
            _query_params.append(('priority', _params['priority']))

        if _params.get('label') is not None:  # noqa: E501
            _query_params.append(('label', _params['label']))

        if _params.get('app') is not None:  # noqa: E501
            _query_params.append(('app', _params['app']))

        if _params.get('app_args') is not None:  # noqa: E501
            _query_params.append(('appArgs', _params['app_args']))

        if _params.get('caller_id') is not None:  # noqa: E501
            _query_params.append(('callerId', _params['caller_id']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        if _params.get('other_channel_id') is not None:  # noqa: E501
            _query_params.append(('otherChannelId', _params['other_channel_id']))

        if _params.get('originator') is not None:  # noqa: E501
            _query_params.append(('originator', _params['originator']))

        if _params.get('formats') is not None:  # noqa: E501
            _query_params.append(('formats', _params['formats']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['variables'] is not None:
            _body_params = _params['variables']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Channel",
        }

        return await self.api_client.call_api(
            '/channels/{channelId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def play_sound_with_id(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], playback_id : Annotated[StrictStr, Field(..., description="Playback ID.")], media : Annotated[conlist(StrictStr), Field(..., description="Media URIs to play.")], lang : Annotated[Optional[StrictStr], Field(description="For sounds, selects language for sound.")] = None, offsetms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.")] = None, skipms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip for forward/reverse operations.")] = None, **kwargs) -> Playback:  # noqa: E501
        """Start playback of media and specify the playbackId.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param playback_id: Playback ID. (required)
        :type playback_id: str
        :param media: Media URIs to play. (required)
        :type media: List[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Playback
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the play_sound_with_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.play_sound_with_id_with_http_info(channel_id, playback_id, media, lang, offsetms, skipms, **kwargs)  # noqa: E501

    @validate_arguments
    async def play_sound_with_id_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], playback_id : Annotated[StrictStr, Field(..., description="Playback ID.")], media : Annotated[conlist(StrictStr), Field(..., description="Media URIs to play.")], lang : Annotated[Optional[StrictStr], Field(description="For sounds, selects language for sound.")] = None, offsetms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.")] = None, skipms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip for forward/reverse operations.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Start playback of media and specify the playbackId.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param playback_id: Playback ID. (required)
        :type playback_id: str
        :param media: Media URIs to play. (required)
        :type media: List[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Playback, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'playback_id',
            'media',
            'lang',
            'offsetms',
            'skipms'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method play_sound_with_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']

        if _params['playback_id'] is not None:
            _path_params['playbackId'] = _params['playback_id']


        # process the query parameters
        _query_params = []
        if _params.get('media') is not None:  # noqa: E501
            _query_params.append(('media', _params['media']))
            _collection_formats['media'] = 'csv'

        if _params.get('lang') is not None:  # noqa: E501
            _query_params.append(('lang', _params['lang']))

        if _params.get('offsetms') is not None:  # noqa: E501
            _query_params.append(('offsetms', _params['offsetms']))

        if _params.get('skipms') is not None:  # noqa: E501
            _query_params.append(('skipms', _params['skipms']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Playback",
        }

        return await self.api_client.call_api(
            '/channels/{channelId}/play/{playbackId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def playsound(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], media : Annotated[conlist(StrictStr), Field(..., description="Media URIs to play.")], lang : Annotated[Optional[StrictStr], Field(description="For sounds, selects language for sound.")] = None, offsetms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.")] = None, skipms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip for forward/reverse operations.")] = None, playback_id : Annotated[Optional[StrictStr], Field(description="Playback ID.")] = None, **kwargs) -> Playback:  # noqa: E501
        """Start playback of media.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param media: Media URIs to play. (required)
        :type media: List[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param playback_id: Playback ID.
        :type playback_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Playback
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the playsound_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.playsound_with_http_info(channel_id, media, lang, offsetms, skipms, playback_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def playsound_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], media : Annotated[conlist(StrictStr), Field(..., description="Media URIs to play.")], lang : Annotated[Optional[StrictStr], Field(description="For sounds, selects language for sound.")] = None, offsetms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.")] = None, skipms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip for forward/reverse operations.")] = None, playback_id : Annotated[Optional[StrictStr], Field(description="Playback ID.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Start playback of media.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param media: Media URIs to play. (required)
        :type media: List[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param playback_id: Playback ID.
        :type playback_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Playback, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'media',
            'lang',
            'offsetms',
            'skipms',
            'playback_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method playsound" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('media') is not None:  # noqa: E501
            _query_params.append(('media', _params['media']))
            _collection_formats['media'] = 'csv'

        if _params.get('lang') is not None:  # noqa: E501
            _query_params.append(('lang', _params['lang']))

        if _params.get('offsetms') is not None:  # noqa: E501
            _query_params.append(('offsetms', _params['offsetms']))

        if _params.get('skipms') is not None:  # noqa: E501
            _query_params.append(('skipms', _params['skipms']))

        if _params.get('playback_id') is not None:  # noqa: E501
            _query_params.append(('playbackId', _params['playback_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Playback",
        }

        return await self.api_client.call_api(
            '/channels/{channelId}/play', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def recordchannel(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], name : Annotated[StrictStr, Field(..., description="Recording's filename")], format : Annotated[StrictStr, Field(..., description="Format to encode audio in")], max_duration_seconds : Annotated[Optional[StrictInt], Field(description="Maximum duration of the recording, in seconds. 0 for no limit")] = None, max_silence_seconds : Annotated[Optional[StrictInt], Field(description="Maximum duration of silence, in seconds. 0 for no limit")] = None, if_exists : Annotated[Optional[StrictStr], Field(description="Action to take if a recording with the same name already exists.")] = None, beep : Annotated[Optional[StrictBool], Field(description="Play beep when recording begins")] = None, terminate_on : Annotated[Optional[StrictStr], Field(description="DTMF input to terminate recording")] = None, **kwargs) -> LiveRecording:  # noqa: E501
        """Start a recording.  # noqa: E501

        Record audio from a channel. Note that this will not capture audio sent to the channel. The bridge itself has a record feature if that's what you want.  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param name: Recording's filename (required)
        :type name: str
        :param format: Format to encode audio in (required)
        :type format: str
        :param max_duration_seconds: Maximum duration of the recording, in seconds. 0 for no limit
        :type max_duration_seconds: int
        :param max_silence_seconds: Maximum duration of silence, in seconds. 0 for no limit
        :type max_silence_seconds: int
        :param if_exists: Action to take if a recording with the same name already exists.
        :type if_exists: str
        :param beep: Play beep when recording begins
        :type beep: bool
        :param terminate_on: DTMF input to terminate recording
        :type terminate_on: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LiveRecording
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the recordchannel_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.recordchannel_with_http_info(channel_id, name, format, max_duration_seconds, max_silence_seconds, if_exists, beep, terminate_on, **kwargs)  # noqa: E501

    @validate_arguments
    async def recordchannel_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], name : Annotated[StrictStr, Field(..., description="Recording's filename")], format : Annotated[StrictStr, Field(..., description="Format to encode audio in")], max_duration_seconds : Annotated[Optional[StrictInt], Field(description="Maximum duration of the recording, in seconds. 0 for no limit")] = None, max_silence_seconds : Annotated[Optional[StrictInt], Field(description="Maximum duration of silence, in seconds. 0 for no limit")] = None, if_exists : Annotated[Optional[StrictStr], Field(description="Action to take if a recording with the same name already exists.")] = None, beep : Annotated[Optional[StrictBool], Field(description="Play beep when recording begins")] = None, terminate_on : Annotated[Optional[StrictStr], Field(description="DTMF input to terminate recording")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Start a recording.  # noqa: E501

        Record audio from a channel. Note that this will not capture audio sent to the channel. The bridge itself has a record feature if that's what you want.  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param name: Recording's filename (required)
        :type name: str
        :param format: Format to encode audio in (required)
        :type format: str
        :param max_duration_seconds: Maximum duration of the recording, in seconds. 0 for no limit
        :type max_duration_seconds: int
        :param max_silence_seconds: Maximum duration of silence, in seconds. 0 for no limit
        :type max_silence_seconds: int
        :param if_exists: Action to take if a recording with the same name already exists.
        :type if_exists: str
        :param beep: Play beep when recording begins
        :type beep: bool
        :param terminate_on: DTMF input to terminate recording
        :type terminate_on: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LiveRecording, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'name',
            'format',
            'max_duration_seconds',
            'max_silence_seconds',
            'if_exists',
            'beep',
            'terminate_on'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recordchannel" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        if _params.get('max_duration_seconds') is not None:  # noqa: E501
            _query_params.append(('maxDurationSeconds', _params['max_duration_seconds']))

        if _params.get('max_silence_seconds') is not None:  # noqa: E501
            _query_params.append(('maxSilenceSeconds', _params['max_silence_seconds']))

        if _params.get('if_exists') is not None:  # noqa: E501
            _query_params.append(('ifExists', _params['if_exists']))

        if _params.get('beep') is not None:  # noqa: E501
            _query_params.append(('beep', _params['beep']))

        if _params.get('terminate_on') is not None:  # noqa: E501
            _query_params.append(('terminateOn', _params['terminate_on']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "LiveRecording",
        }

        return await self.api_client.call_api(
            '/channels/{channelId}/record', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def redirect(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], endpoint : Annotated[StrictStr, Field(..., description="The endpoint to redirect the channel to")], **kwargs) -> None:  # noqa: E501
        """Redirect the channel to a different location.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param endpoint: The endpoint to redirect the channel to (required)
        :type endpoint: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the redirect_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.redirect_with_http_info(channel_id, endpoint, **kwargs)  # noqa: E501

    @validate_arguments
    async def redirect_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], endpoint : Annotated[StrictStr, Field(..., description="The endpoint to redirect the channel to")], **kwargs) -> ApiResponse:  # noqa: E501
        """Redirect the channel to a different location.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param endpoint: The endpoint to redirect the channel to (required)
        :type endpoint: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'endpoint'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redirect" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('endpoint') is not None:  # noqa: E501
            _query_params.append(('endpoint', _params['endpoint']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/redirect', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def ring(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> None:  # noqa: E501
        """Indicate ringing to a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the ring_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.ring_with_http_info(channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def ring_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Indicate ringing to a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ring" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/ring', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def ring_stop(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> None:  # noqa: E501
        """Stop ringing indication on a channel if locally generated.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the ring_stop_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.ring_stop_with_http_info(channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def ring_stop_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stop ringing indication on a channel if locally generated.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ring_stop" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/ring', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def rtpstatistics(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> RTPstat:  # noqa: E501
        """RTP stats on a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RTPstat
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the rtpstatistics_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.rtpstatistics_with_http_info(channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def rtpstatistics_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """RTP stats on a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RTPstat, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rtpstatistics" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "RTPstat",
        }

        return await self.api_client.call_api(
            '/channels/{channelId}/rtp_statistics', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def send_dtmf(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], dtmf : Annotated[Optional[StrictStr], Field(description="DTMF To send.")] = None, before : Annotated[Optional[StrictInt], Field(description="Amount of time to wait before DTMF digits (specified in milliseconds) start.")] = None, between : Annotated[Optional[StrictInt], Field(description="Amount of time in between DTMF digits (specified in milliseconds).")] = None, duration : Annotated[Optional[StrictInt], Field(description="Length of each DTMF digit (specified in milliseconds).")] = None, after : Annotated[Optional[StrictInt], Field(description="Amount of time to wait after DTMF digits (specified in milliseconds) end.")] = None, **kwargs) -> None:  # noqa: E501
        """Send provided DTMF to a given channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param dtmf: DTMF To send.
        :type dtmf: str
        :param before: Amount of time to wait before DTMF digits (specified in milliseconds) start.
        :type before: int
        :param between: Amount of time in between DTMF digits (specified in milliseconds).
        :type between: int
        :param duration: Length of each DTMF digit (specified in milliseconds).
        :type duration: int
        :param after: Amount of time to wait after DTMF digits (specified in milliseconds) end.
        :type after: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the send_dtmf_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.send_dtmf_with_http_info(channel_id, dtmf, before, between, duration, after, **kwargs)  # noqa: E501

    @validate_arguments
    async def send_dtmf_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], dtmf : Annotated[Optional[StrictStr], Field(description="DTMF To send.")] = None, before : Annotated[Optional[StrictInt], Field(description="Amount of time to wait before DTMF digits (specified in milliseconds) start.")] = None, between : Annotated[Optional[StrictInt], Field(description="Amount of time in between DTMF digits (specified in milliseconds).")] = None, duration : Annotated[Optional[StrictInt], Field(description="Length of each DTMF digit (specified in milliseconds).")] = None, after : Annotated[Optional[StrictInt], Field(description="Amount of time to wait after DTMF digits (specified in milliseconds) end.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Send provided DTMF to a given channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param dtmf: DTMF To send.
        :type dtmf: str
        :param before: Amount of time to wait before DTMF digits (specified in milliseconds) start.
        :type before: int
        :param between: Amount of time in between DTMF digits (specified in milliseconds).
        :type between: int
        :param duration: Length of each DTMF digit (specified in milliseconds).
        :type duration: int
        :param after: Amount of time to wait after DTMF digits (specified in milliseconds) end.
        :type after: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'dtmf',
            'before',
            'between',
            'duration',
            'after'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_dtmf" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('dtmf') is not None:  # noqa: E501
            _query_params.append(('dtmf', _params['dtmf']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('between') is not None:  # noqa: E501
            _query_params.append(('between', _params['between']))

        if _params.get('duration') is not None:  # noqa: E501
            _query_params.append(('duration', _params['duration']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/dtmf', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def set_channel_var(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], variable : Annotated[StrictStr, Field(..., description="The channel variable or function to set")], value : Annotated[Optional[StrictStr], Field(description="The value to set the variable to")] = None, **kwargs) -> None:  # noqa: E501
        """Set the value of a channel variable or function.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param variable: The channel variable or function to set (required)
        :type variable: str
        :param value: The value to set the variable to
        :type value: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the set_channel_var_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.set_channel_var_with_http_info(channel_id, variable, value, **kwargs)  # noqa: E501

    @validate_arguments
    async def set_channel_var_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], variable : Annotated[StrictStr, Field(..., description="The channel variable or function to set")], value : Annotated[Optional[StrictStr], Field(description="The value to set the variable to")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Set the value of a channel variable or function.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param variable: The channel variable or function to set (required)
        :type variable: str
        :param value: The value to set the variable to
        :type value: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'variable',
            'value'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_channel_var" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('variable') is not None:  # noqa: E501
            _query_params.append(('variable', _params['variable']))

        if _params.get('value') is not None:  # noqa: E501
            _query_params.append(('value', _params['value']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/variable', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def snoop_channel(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], app : Annotated[StrictStr, Field(..., description="Application the snooping channel is placed into")], spy : Annotated[Optional[StrictStr], Field(description="Direction of audio to spy on")] = None, whisper : Annotated[Optional[StrictStr], Field(description="Direction of audio to whisper into")] = None, app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application")] = None, snoop_id : Annotated[Optional[StrictStr], Field(description="Unique ID to assign to snooping channel")] = None, **kwargs) -> Channel:  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param app: Application the snooping channel is placed into (required)
        :type app: str
        :param spy: Direction of audio to spy on
        :type spy: str
        :param whisper: Direction of audio to whisper into
        :type whisper: str
        :param app_args: The application arguments to pass to the Stasis application
        :type app_args: str
        :param snoop_id: Unique ID to assign to snooping channel
        :type snoop_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the snoop_channel_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.snoop_channel_with_http_info(channel_id, app, spy, whisper, app_args, snoop_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def snoop_channel_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], app : Annotated[StrictStr, Field(..., description="Application the snooping channel is placed into")], spy : Annotated[Optional[StrictStr], Field(description="Direction of audio to spy on")] = None, whisper : Annotated[Optional[StrictStr], Field(description="Direction of audio to whisper into")] = None, app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application")] = None, snoop_id : Annotated[Optional[StrictStr], Field(description="Unique ID to assign to snooping channel")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param app: Application the snooping channel is placed into (required)
        :type app: str
        :param spy: Direction of audio to spy on
        :type spy: str
        :param whisper: Direction of audio to whisper into
        :type whisper: str
        :param app_args: The application arguments to pass to the Stasis application
        :type app_args: str
        :param snoop_id: Unique ID to assign to snooping channel
        :type snoop_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'app',
            'spy',
            'whisper',
            'app_args',
            'snoop_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method snoop_channel" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('spy') is not None:  # noqa: E501
            _query_params.append(('spy', _params['spy']))

        if _params.get('whisper') is not None:  # noqa: E501
            _query_params.append(('whisper', _params['whisper']))

        if _params.get('app') is not None:  # noqa: E501
            _query_params.append(('app', _params['app']))

        if _params.get('app_args') is not None:  # noqa: E501
            _query_params.append(('appArgs', _params['app_args']))

        if _params.get('snoop_id') is not None:  # noqa: E501
            _query_params.append(('snoopId', _params['snoop_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Channel",
        }

        return await self.api_client.call_api(
            '/channels/{channelId}/snoop', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def snoop_channel_with_id(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], snoop_id : Annotated[StrictStr, Field(..., description="Unique ID to assign to snooping channel")], app : Annotated[StrictStr, Field(..., description="Application the snooping channel is placed into")], spy : Annotated[Optional[StrictStr], Field(description="Direction of audio to spy on")] = None, whisper : Annotated[Optional[StrictStr], Field(description="Direction of audio to whisper into")] = None, app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application")] = None, **kwargs) -> Channel:  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param snoop_id: Unique ID to assign to snooping channel (required)
        :type snoop_id: str
        :param app: Application the snooping channel is placed into (required)
        :type app: str
        :param spy: Direction of audio to spy on
        :type spy: str
        :param whisper: Direction of audio to whisper into
        :type whisper: str
        :param app_args: The application arguments to pass to the Stasis application
        :type app_args: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Channel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the snoop_channel_with_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.snoop_channel_with_id_with_http_info(channel_id, snoop_id, app, spy, whisper, app_args, **kwargs)  # noqa: E501

    @validate_arguments
    async def snoop_channel_with_id_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], snoop_id : Annotated[StrictStr, Field(..., description="Unique ID to assign to snooping channel")], app : Annotated[StrictStr, Field(..., description="Application the snooping channel is placed into")], spy : Annotated[Optional[StrictStr], Field(description="Direction of audio to spy on")] = None, whisper : Annotated[Optional[StrictStr], Field(description="Direction of audio to whisper into")] = None, app_args : Annotated[Optional[StrictStr], Field(description="The application arguments to pass to the Stasis application")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Start snooping.  # noqa: E501

        Snoop (spy/whisper) on a specific channel.  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param snoop_id: Unique ID to assign to snooping channel (required)
        :type snoop_id: str
        :param app: Application the snooping channel is placed into (required)
        :type app: str
        :param spy: Direction of audio to spy on
        :type spy: str
        :param whisper: Direction of audio to whisper into
        :type whisper: str
        :param app_args: The application arguments to pass to the Stasis application
        :type app_args: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Channel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'snoop_id',
            'app',
            'spy',
            'whisper',
            'app_args'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method snoop_channel_with_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']

        if _params['snoop_id'] is not None:
            _path_params['snoopId'] = _params['snoop_id']


        # process the query parameters
        _query_params = []
        if _params.get('spy') is not None:  # noqa: E501
            _query_params.append(('spy', _params['spy']))

        if _params.get('whisper') is not None:  # noqa: E501
            _query_params.append(('whisper', _params['whisper']))

        if _params.get('app') is not None:  # noqa: E501
            _query_params.append(('app', _params['app']))

        if _params.get('app_args') is not None:  # noqa: E501
            _query_params.append(('appArgs', _params['app_args']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Channel",
        }

        return await self.api_client.call_api(
            '/channels/{channelId}/snoop/{snoopId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def start_silence(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> None:  # noqa: E501
        """Play silence to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing silence in this manner will suspend silence without resuming automatically.  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the start_silence_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.start_silence_with_http_info(channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def start_silence_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Play silence to a channel.  # noqa: E501

        Using media operations such as /play on a channel playing silence in this manner will suspend silence without resuming automatically.  # noqa: E501

        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_silence" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/silence', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def stop_silence(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> None:  # noqa: E501
        """Stop playing silence to a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the stop_silence_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.stop_silence_with_http_info(channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def stop_silence_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stop playing silence to a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_silence" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/silence', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def unhold(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> None:  # noqa: E501
        """Remove a channel from hold.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the unhold_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.unhold_with_http_info(channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def unhold_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Remove a channel from hold.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unhold" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/hold', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def unmute(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], direction : Annotated[Optional[StrictStr], Field(description="Direction in which to unmute audio")] = None, **kwargs) -> None:  # noqa: E501
        """Unmute a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param direction: Direction in which to unmute audio
        :type direction: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the unmute_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.unmute_with_http_info(channel_id, direction, **kwargs)  # noqa: E501

    @validate_arguments
    async def unmute_with_http_info(self, channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], direction : Annotated[Optional[StrictStr], Field(description="Direction in which to unmute audio")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Unmute a channel.  # noqa: E501


        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param direction: Direction in which to unmute audio
        :type direction: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'channel_id',
            'direction'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unmute" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        if _params.get('direction') is not None:  # noqa: E501
            _query_params.append(('direction', _params['direction']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/channels/{channelId}/mute', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
