# coding: utf-8

"""
    Asterisk ARI

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 6.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional, Union
from pydantic import BaseModel, Field, StrictStr

from typing import TYPE_CHECKING
from importlib import import_module
if TYPE_CHECKING:
    from ari_sync_sdk.models.application_move_failed import ApplicationMoveFailed
    from ari_sync_sdk.models.application_replaced import ApplicationReplaced
    from ari_sync_sdk.models.bridge_attended_transfer import BridgeAttendedTransfer
    from ari_sync_sdk.models.bridge_blind_transfer import BridgeBlindTransfer
    from ari_sync_sdk.models.bridge_created import BridgeCreated
    from ari_sync_sdk.models.bridge_destroyed import BridgeDestroyed
    from ari_sync_sdk.models.bridge_merged import BridgeMerged
    from ari_sync_sdk.models.bridge_video_source_changed import BridgeVideoSourceChanged
    from ari_sync_sdk.models.channel_caller_id import ChannelCallerId
    from ari_sync_sdk.models.channel_connected_line import ChannelConnectedLine
    from ari_sync_sdk.models.channel_created import ChannelCreated
    from ari_sync_sdk.models.channel_destroyed import ChannelDestroyed
    from ari_sync_sdk.models.channel_dialplan import ChannelDialplan
    from ari_sync_sdk.models.channel_dtmf_received import ChannelDtmfReceived
    from ari_sync_sdk.models.channel_entered_bridge import ChannelEnteredBridge
    from ari_sync_sdk.models.channel_hangup_request import ChannelHangupRequest
    from ari_sync_sdk.models.channel_hold import ChannelHold
    from ari_sync_sdk.models.channel_left_bridge import ChannelLeftBridge
    from ari_sync_sdk.models.channel_state_change import ChannelStateChange
    from ari_sync_sdk.models.channel_talking_finished import ChannelTalkingFinished
    from ari_sync_sdk.models.channel_talking_started import ChannelTalkingStarted
    from ari_sync_sdk.models.channel_unhold import ChannelUnhold
    from ari_sync_sdk.models.channel_userevent import ChannelUserevent
    from ari_sync_sdk.models.channel_varset import ChannelVarset
    from ari_sync_sdk.models.contact_status_change import ContactStatusChange
    from ari_sync_sdk.models.device_state_changed import DeviceStateChanged
    from ari_sync_sdk.models.dial import Dial
    from ari_sync_sdk.models.endpoint_state_change import EndpointStateChange
    from ari_sync_sdk.models.event import Event
    from ari_sync_sdk.models.missing_params import MissingParams
    from ari_sync_sdk.models.peer_status_change import PeerStatusChange
    from ari_sync_sdk.models.playback_continuing import PlaybackContinuing
    from ari_sync_sdk.models.playback_finished import PlaybackFinished
    from ari_sync_sdk.models.playback_started import PlaybackStarted
    from ari_sync_sdk.models.recording_failed import RecordingFailed
    from ari_sync_sdk.models.recording_finished import RecordingFinished
    from ari_sync_sdk.models.recording_started import RecordingStarted
    from ari_sync_sdk.models.stasis_end import StasisEnd
    from ari_sync_sdk.models.stasis_start import StasisStart
    from ari_sync_sdk.models.text_message_received import TextMessageReceived

class Message(BaseModel):
    """
    Base type for errors and events  # noqa: E501
    """
    asterisk_id: Optional[StrictStr] = Field(default=None, description="The unique ID for the Asterisk instance that raised this event.")
    type: StrictStr = Field(default=..., description="Indicates the type of this message.")
    __properties = ["asterisk_id", "type"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    # JSON field name that stores the object type
    __discriminator_property_name = 'type'

    # discriminator mappings
    __discriminator_value_class_map = {
        'ApplicationMoveFailed': 'ApplicationMoveFailed',
        'ApplicationReplaced': 'ApplicationReplaced',
        'BridgeAttendedTransfer': 'BridgeAttendedTransfer',
        'BridgeBlindTransfer': 'BridgeBlindTransfer',
        'BridgeCreated': 'BridgeCreated',
        'BridgeDestroyed': 'BridgeDestroyed',
        'BridgeMerged': 'BridgeMerged',
        'BridgeVideoSourceChanged': 'BridgeVideoSourceChanged',
        'ChannelCallerId': 'ChannelCallerId',
        'ChannelConnectedLine': 'ChannelConnectedLine',
        'ChannelCreated': 'ChannelCreated',
        'ChannelDestroyed': 'ChannelDestroyed',
        'ChannelDialplan': 'ChannelDialplan',
        'ChannelDtmfReceived': 'ChannelDtmfReceived',
        'ChannelEnteredBridge': 'ChannelEnteredBridge',
        'ChannelHangupRequest': 'ChannelHangupRequest',
        'ChannelHold': 'ChannelHold',
        'ChannelLeftBridge': 'ChannelLeftBridge',
        'ChannelStateChange': 'ChannelStateChange',
        'ChannelTalkingFinished': 'ChannelTalkingFinished',
        'ChannelTalkingStarted': 'ChannelTalkingStarted',
        'ChannelUnhold': 'ChannelUnhold',
        'ChannelUserevent': 'ChannelUserevent',
        'ChannelVarset': 'ChannelVarset',
        'ContactStatusChange': 'ContactStatusChange',
        'DeviceStateChanged': 'DeviceStateChanged',
        'Dial': 'Dial',
        'EndpointStateChange': 'EndpointStateChange',
        'Event': 'Event',
        'MissingParams': 'MissingParams',
        'PeerStatusChange': 'PeerStatusChange',
        'PlaybackContinuing': 'PlaybackContinuing',
        'PlaybackFinished': 'PlaybackFinished',
        'PlaybackStarted': 'PlaybackStarted',
        'RecordingFailed': 'RecordingFailed',
        'RecordingFinished': 'RecordingFinished',
        'RecordingStarted': 'RecordingStarted',
        'StasisEnd': 'StasisEnd',
        'StasisStart': 'StasisStart',
        'TextMessageReceived': 'TextMessageReceived'
    }

    @classmethod
    def get_discriminator_value(cls, obj: dict) -> str:
        """Returns the discriminator value (object type) of the data"""
        discriminator_value = obj[cls.__discriminator_property_name]
        if discriminator_value:
            return cls.__discriminator_value_class_map.get(discriminator_value)
        else:
            return None

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Union(ApplicationMoveFailed, ApplicationReplaced, BridgeAttendedTransfer, BridgeBlindTransfer, BridgeCreated, BridgeDestroyed, BridgeMerged, BridgeVideoSourceChanged, ChannelCallerId, ChannelConnectedLine, ChannelCreated, ChannelDestroyed, ChannelDialplan, ChannelDtmfReceived, ChannelEnteredBridge, ChannelHangupRequest, ChannelHold, ChannelLeftBridge, ChannelStateChange, ChannelTalkingFinished, ChannelTalkingStarted, ChannelUnhold, ChannelUserevent, ChannelVarset, ContactStatusChange, DeviceStateChanged, Dial, EndpointStateChange, Event, MissingParams, PeerStatusChange, PlaybackContinuing, PlaybackFinished, PlaybackStarted, RecordingFailed, RecordingFinished, RecordingStarted, StasisEnd, StasisStart, TextMessageReceived):
        """Create an instance of Message from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Union(ApplicationMoveFailed, ApplicationReplaced, BridgeAttendedTransfer, BridgeBlindTransfer, BridgeCreated, BridgeDestroyed, BridgeMerged, BridgeVideoSourceChanged, ChannelCallerId, ChannelConnectedLine, ChannelCreated, ChannelDestroyed, ChannelDialplan, ChannelDtmfReceived, ChannelEnteredBridge, ChannelHangupRequest, ChannelHold, ChannelLeftBridge, ChannelStateChange, ChannelTalkingFinished, ChannelTalkingStarted, ChannelUnhold, ChannelUserevent, ChannelVarset, ContactStatusChange, DeviceStateChanged, Dial, EndpointStateChange, Event, MissingParams, PeerStatusChange, PlaybackContinuing, PlaybackFinished, PlaybackStarted, RecordingFailed, RecordingFinished, RecordingStarted, StasisEnd, StasisStart, TextMessageReceived):
        """Create an instance of Message from a dict"""
        # look up the object type based on discriminator mapping
        object_type = cls.get_discriminator_value(obj)
        if object_type ==  'ApplicationMoveFailed':
            return import_module("ari_sync_sdk.models.application_move_failed").ApplicationMoveFailed.from_dict(obj)
        if object_type ==  'ApplicationReplaced':
            return import_module("ari_sync_sdk.models.application_replaced").ApplicationReplaced.from_dict(obj)
        if object_type ==  'BridgeAttendedTransfer':
            return import_module("ari_sync_sdk.models.bridge_attended_transfer").BridgeAttendedTransfer.from_dict(obj)
        if object_type ==  'BridgeBlindTransfer':
            return import_module("ari_sync_sdk.models.bridge_blind_transfer").BridgeBlindTransfer.from_dict(obj)
        if object_type ==  'BridgeCreated':
            return import_module("ari_sync_sdk.models.bridge_created").BridgeCreated.from_dict(obj)
        if object_type ==  'BridgeDestroyed':
            return import_module("ari_sync_sdk.models.bridge_destroyed").BridgeDestroyed.from_dict(obj)
        if object_type ==  'BridgeMerged':
            return import_module("ari_sync_sdk.models.bridge_merged").BridgeMerged.from_dict(obj)
        if object_type ==  'BridgeVideoSourceChanged':
            return import_module("ari_sync_sdk.models.bridge_video_source_changed").BridgeVideoSourceChanged.from_dict(obj)
        if object_type ==  'ChannelCallerId':
            return import_module("ari_sync_sdk.models.channel_caller_id").ChannelCallerId.from_dict(obj)
        if object_type ==  'ChannelConnectedLine':
            return import_module("ari_sync_sdk.models.channel_connected_line").ChannelConnectedLine.from_dict(obj)
        if object_type ==  'ChannelCreated':
            return import_module("ari_sync_sdk.models.channel_created").ChannelCreated.from_dict(obj)
        if object_type ==  'ChannelDestroyed':
            return import_module("ari_sync_sdk.models.channel_destroyed").ChannelDestroyed.from_dict(obj)
        if object_type ==  'ChannelDialplan':
            return import_module("ari_sync_sdk.models.channel_dialplan").ChannelDialplan.from_dict(obj)
        if object_type ==  'ChannelDtmfReceived':
            return import_module("ari_sync_sdk.models.channel_dtmf_received").ChannelDtmfReceived.from_dict(obj)
        if object_type ==  'ChannelEnteredBridge':
            return import_module("ari_sync_sdk.models.channel_entered_bridge").ChannelEnteredBridge.from_dict(obj)
        if object_type ==  'ChannelHangupRequest':
            return import_module("ari_sync_sdk.models.channel_hangup_request").ChannelHangupRequest.from_dict(obj)
        if object_type ==  'ChannelHold':
            return import_module("ari_sync_sdk.models.channel_hold").ChannelHold.from_dict(obj)
        if object_type ==  'ChannelLeftBridge':
            return import_module("ari_sync_sdk.models.channel_left_bridge").ChannelLeftBridge.from_dict(obj)
        if object_type ==  'ChannelStateChange':
            return import_module("ari_sync_sdk.models.channel_state_change").ChannelStateChange.from_dict(obj)
        if object_type ==  'ChannelTalkingFinished':
            return import_module("ari_sync_sdk.models.channel_talking_finished").ChannelTalkingFinished.from_dict(obj)
        if object_type ==  'ChannelTalkingStarted':
            return import_module("ari_sync_sdk.models.channel_talking_started").ChannelTalkingStarted.from_dict(obj)
        if object_type ==  'ChannelUnhold':
            return import_module("ari_sync_sdk.models.channel_unhold").ChannelUnhold.from_dict(obj)
        if object_type ==  'ChannelUserevent':
            return import_module("ari_sync_sdk.models.channel_userevent").ChannelUserevent.from_dict(obj)
        if object_type ==  'ChannelVarset':
            return import_module("ari_sync_sdk.models.channel_varset").ChannelVarset.from_dict(obj)
        if object_type ==  'ContactStatusChange':
            return import_module("ari_sync_sdk.models.contact_status_change").ContactStatusChange.from_dict(obj)
        if object_type ==  'DeviceStateChanged':
            return import_module("ari_sync_sdk.models.device_state_changed").DeviceStateChanged.from_dict(obj)
        if object_type ==  'Dial':
            return import_module("ari_sync_sdk.models.dial").Dial.from_dict(obj)
        if object_type ==  'EndpointStateChange':
            return import_module("ari_sync_sdk.models.endpoint_state_change").EndpointStateChange.from_dict(obj)
        if object_type ==  'Event':
            return import_module("ari_sync_sdk.models.event").Event.from_dict(obj)
        if object_type ==  'MissingParams':
            return import_module("ari_sync_sdk.models.missing_params").MissingParams.from_dict(obj)
        if object_type ==  'PeerStatusChange':
            return import_module("ari_sync_sdk.models.peer_status_change").PeerStatusChange.from_dict(obj)
        if object_type ==  'PlaybackContinuing':
            return import_module("ari_sync_sdk.models.playback_continuing").PlaybackContinuing.from_dict(obj)
        if object_type ==  'PlaybackFinished':
            return import_module("ari_sync_sdk.models.playback_finished").PlaybackFinished.from_dict(obj)
        if object_type ==  'PlaybackStarted':
            return import_module("ari_sync_sdk.models.playback_started").PlaybackStarted.from_dict(obj)
        if object_type ==  'RecordingFailed':
            return import_module("ari_sync_sdk.models.recording_failed").RecordingFailed.from_dict(obj)
        if object_type ==  'RecordingFinished':
            return import_module("ari_sync_sdk.models.recording_finished").RecordingFinished.from_dict(obj)
        if object_type ==  'RecordingStarted':
            return import_module("ari_sync_sdk.models.recording_started").RecordingStarted.from_dict(obj)
        if object_type ==  'StasisEnd':
            return import_module("ari_sync_sdk.models.stasis_end").StasisEnd.from_dict(obj)
        if object_type ==  'StasisStart':
            return import_module("ari_sync_sdk.models.stasis_start").StasisStart.from_dict(obj)
        if object_type ==  'TextMessageReceived':
            return import_module("ari_sync_sdk.models.text_message_received").TextMessageReceived.from_dict(obj)
        raise ValueError("Message failed to lookup discriminator value from " +
                            json.dumps(obj) + ". Discriminator property name: " + cls.__discriminator_property_name +
                            ", mapping: " + json.dumps(cls.__discriminator_value_class_map))


