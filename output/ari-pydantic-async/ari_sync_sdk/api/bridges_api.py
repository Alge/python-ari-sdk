# coding: utf-8

"""
    Asterisk ARI

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 6.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing import overload, Optional, Union, Awaitable

from typing_extensions import Annotated
from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist

from typing import List, Optional

from ari_sync_sdk.models.bridge import Bridge
from ari_sync_sdk.models.live_recording import LiveRecording
from ari_sync_sdk.models.playback import Playback

from ari_sync_sdk.api_client import ApiClient
from ari_sync_sdk.api_response import ApiResponse
from ari_sync_sdk.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class BridgesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    async def add_channel(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], channel : Annotated[conlist(StrictStr), Field(..., description="Ids of channels to add to bridge")], role : Annotated[Optional[StrictStr], Field(description="Channel's role in the bridge")] = None, absorb_dtmf : Annotated[Optional[StrictBool], Field(description="Absorb DTMF coming from this channel, preventing it to pass through to the bridge")] = None, mute : Annotated[Optional[StrictBool], Field(description="Mute audio from this channel, preventing it to pass through to the bridge")] = None, inhibit_connected_line_updates : Annotated[Optional[StrictBool], Field(description="Do not present the identity of the newly connected channel to other bridge members")] = None, **kwargs) -> None:  # noqa: E501
        """Add a channel to a bridge.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param channel: Ids of channels to add to bridge (required)
        :type channel: List[str]
        :param role: Channel's role in the bridge
        :type role: str
        :param absorb_dtmf: Absorb DTMF coming from this channel, preventing it to pass through to the bridge
        :type absorb_dtmf: bool
        :param mute: Mute audio from this channel, preventing it to pass through to the bridge
        :type mute: bool
        :param inhibit_connected_line_updates: Do not present the identity of the newly connected channel to other bridge members
        :type inhibit_connected_line_updates: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the add_channel_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.add_channel_with_http_info(bridge_id, channel, role, absorb_dtmf, mute, inhibit_connected_line_updates, **kwargs)  # noqa: E501

    @validate_arguments
    async def add_channel_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], channel : Annotated[conlist(StrictStr), Field(..., description="Ids of channels to add to bridge")], role : Annotated[Optional[StrictStr], Field(description="Channel's role in the bridge")] = None, absorb_dtmf : Annotated[Optional[StrictBool], Field(description="Absorb DTMF coming from this channel, preventing it to pass through to the bridge")] = None, mute : Annotated[Optional[StrictBool], Field(description="Mute audio from this channel, preventing it to pass through to the bridge")] = None, inhibit_connected_line_updates : Annotated[Optional[StrictBool], Field(description="Do not present the identity of the newly connected channel to other bridge members")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Add a channel to a bridge.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param channel: Ids of channels to add to bridge (required)
        :type channel: List[str]
        :param role: Channel's role in the bridge
        :type role: str
        :param absorb_dtmf: Absorb DTMF coming from this channel, preventing it to pass through to the bridge
        :type absorb_dtmf: bool
        :param mute: Mute audio from this channel, preventing it to pass through to the bridge
        :type mute: bool
        :param inhibit_connected_line_updates: Do not present the identity of the newly connected channel to other bridge members
        :type inhibit_connected_line_updates: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'bridge_id',
            'channel',
            'role',
            'absorb_dtmf',
            'mute',
            'inhibit_connected_line_updates'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_channel" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']


        # process the query parameters
        _query_params = []
        if _params.get('channel') is not None:  # noqa: E501
            _query_params.append(('channel', _params['channel']))
            _collection_formats['channel'] = 'csv'

        if _params.get('role') is not None:  # noqa: E501
            _query_params.append(('role', _params['role']))

        if _params.get('absorb_dtmf') is not None:  # noqa: E501
            _query_params.append(('absorbDTMF', _params['absorb_dtmf']))

        if _params.get('mute') is not None:  # noqa: E501
            _query_params.append(('mute', _params['mute']))

        if _params.get('inhibit_connected_line_updates') is not None:  # noqa: E501
            _query_params.append(('inhibitConnectedLineUpdates', _params['inhibit_connected_line_updates']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/bridges/{bridgeId}/addChannel', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def clear_video_source(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], **kwargs) -> None:  # noqa: E501
        """Removes any explicit video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants. When no explicit video source is set, talk detection will be used to determine the active video stream.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the clear_video_source_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.clear_video_source_with_http_info(bridge_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def clear_video_source_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Removes any explicit video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants. When no explicit video source is set, talk detection will be used to determine the active video stream.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'bridge_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_video_source" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/bridges/{bridgeId}/videoSource', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def create(self, type : Annotated[Optional[StrictStr], Field(description="Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu).")] = None, bridge_id : Annotated[Optional[StrictStr], Field(description="Unique ID to give to the bridge being created.")] = None, name : Annotated[Optional[StrictStr], Field(description="Name to give to the bridge being created.")] = None, **kwargs) -> Bridge:  # noqa: E501
        """Create a new bridge.  # noqa: E501

        This bridge persists until it has been shut down, or Asterisk has been shut down.  # noqa: E501

        :param type: Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu).
        :type type: str
        :param bridge_id: Unique ID to give to the bridge being created.
        :type bridge_id: str
        :param name: Name to give to the bridge being created.
        :type name: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Bridge
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_with_http_info(type, bridge_id, name, **kwargs)  # noqa: E501

    @validate_arguments
    async def create_with_http_info(self, type : Annotated[Optional[StrictStr], Field(description="Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu).")] = None, bridge_id : Annotated[Optional[StrictStr], Field(description="Unique ID to give to the bridge being created.")] = None, name : Annotated[Optional[StrictStr], Field(description="Name to give to the bridge being created.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a new bridge.  # noqa: E501

        This bridge persists until it has been shut down, or Asterisk has been shut down.  # noqa: E501

        :param type: Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu).
        :type type: str
        :param bridge_id: Unique ID to give to the bridge being created.
        :type bridge_id: str
        :param name: Name to give to the bridge being created.
        :type name: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Bridge, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'type',
            'bridge_id',
            'name'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('type') is not None:  # noqa: E501
            _query_params.append(('type', _params['type']))

        if _params.get('bridge_id') is not None:  # noqa: E501
            _query_params.append(('bridgeId', _params['bridge_id']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Bridge",
        }

        return await self.api_client.call_api(
            '/bridges', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def create_with_id(self, bridge_id : Annotated[StrictStr, Field(..., description="Unique ID to give to the bridge being created.")], type : Annotated[Optional[StrictStr], Field(description="Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu) to set.")] = None, name : Annotated[Optional[StrictStr], Field(description="Set the name of the bridge.")] = None, **kwargs) -> Bridge:  # noqa: E501
        """Create a new bridge or updates an existing one.  # noqa: E501

        This bridge persists until it has been shut down, or Asterisk has been shut down.  # noqa: E501

        :param bridge_id: Unique ID to give to the bridge being created. (required)
        :type bridge_id: str
        :param type: Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu) to set.
        :type type: str
        :param name: Set the name of the bridge.
        :type name: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Bridge
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the create_with_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_with_id_with_http_info(bridge_id, type, name, **kwargs)  # noqa: E501

    @validate_arguments
    async def create_with_id_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Unique ID to give to the bridge being created.")], type : Annotated[Optional[StrictStr], Field(description="Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu) to set.")] = None, name : Annotated[Optional[StrictStr], Field(description="Set the name of the bridge.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a new bridge or updates an existing one.  # noqa: E501

        This bridge persists until it has been shut down, or Asterisk has been shut down.  # noqa: E501

        :param bridge_id: Unique ID to give to the bridge being created. (required)
        :type bridge_id: str
        :param type: Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu) to set.
        :type type: str
        :param name: Set the name of the bridge.
        :type name: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Bridge, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'bridge_id',
            'type',
            'name'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_with_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']


        # process the query parameters
        _query_params = []
        if _params.get('type') is not None:  # noqa: E501
            _query_params.append(('type', _params['type']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Bridge",
        }

        return await self.api_client.call_api(
            '/bridges/{bridgeId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def destroy(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], **kwargs) -> None:  # noqa: E501
        """Shut down a bridge.  # noqa: E501

        If any channels are in this bridge, they will be removed and resume whatever they were doing beforehand.  # noqa: E501

        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the destroy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.destroy_with_http_info(bridge_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def destroy_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Shut down a bridge.  # noqa: E501

        If any channels are in this bridge, they will be removed and resume whatever they were doing beforehand.  # noqa: E501

        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'bridge_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/bridges/{bridgeId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def getbridge(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], **kwargs) -> Bridge:  # noqa: E501
        """Get bridge details.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Bridge
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the getbridge_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.getbridge_with_http_info(bridge_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def getbridge_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get bridge details.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Bridge, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'bridge_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method getbridge" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Bridge",
        }

        return await self.api_client.call_api(
            '/bridges/{bridgeId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def listbridges(self, **kwargs) -> List[Bridge]:  # noqa: E501
        """List all active bridges in Asterisk.  # noqa: E501


        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Bridge]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the listbridges_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.listbridges_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    async def listbridges_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """List all active bridges in Asterisk.  # noqa: E501


        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Bridge], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method listbridges" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[Bridge]",
        }

        return await self.api_client.call_api(
            '/bridges', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def play(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], media : Annotated[conlist(StrictStr), Field(..., description="Media URIs to play.")], lang : Annotated[Optional[StrictStr], Field(description="For sounds, selects language for sound.")] = None, offsetms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.")] = None, skipms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip for forward/reverse operations.")] = None, playback_id : Annotated[Optional[StrictStr], Field(description="Playback Id.")] = None, **kwargs) -> Playback:  # noqa: E501
        """Start playback of media on a bridge.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501

        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param media: Media URIs to play. (required)
        :type media: List[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param playback_id: Playback Id.
        :type playback_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Playback
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the play_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.play_with_http_info(bridge_id, media, lang, offsetms, skipms, playback_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def play_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], media : Annotated[conlist(StrictStr), Field(..., description="Media URIs to play.")], lang : Annotated[Optional[StrictStr], Field(description="For sounds, selects language for sound.")] = None, offsetms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.")] = None, skipms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip for forward/reverse operations.")] = None, playback_id : Annotated[Optional[StrictStr], Field(description="Playback Id.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Start playback of media on a bridge.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501

        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param media: Media URIs to play. (required)
        :type media: List[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param playback_id: Playback Id.
        :type playback_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Playback, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'bridge_id',
            'media',
            'lang',
            'offsetms',
            'skipms',
            'playback_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method play" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']


        # process the query parameters
        _query_params = []
        if _params.get('media') is not None:  # noqa: E501
            _query_params.append(('media', _params['media']))
            _collection_formats['media'] = 'csv'

        if _params.get('lang') is not None:  # noqa: E501
            _query_params.append(('lang', _params['lang']))

        if _params.get('offsetms') is not None:  # noqa: E501
            _query_params.append(('offsetms', _params['offsetms']))

        if _params.get('skipms') is not None:  # noqa: E501
            _query_params.append(('skipms', _params['skipms']))

        if _params.get('playback_id') is not None:  # noqa: E501
            _query_params.append(('playbackId', _params['playback_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Playback",
        }

        return await self.api_client.call_api(
            '/bridges/{bridgeId}/play', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def play_with_id(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], playback_id : Annotated[StrictStr, Field(..., description="Playback ID.")], media : Annotated[conlist(StrictStr), Field(..., description="Media URIs to play.")], lang : Annotated[Optional[StrictStr], Field(description="For sounds, selects language for sound.")] = None, offsetms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.")] = None, skipms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip for forward/reverse operations.")] = None, **kwargs) -> Playback:  # noqa: E501
        """Start playback of media on a bridge.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501

        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param playback_id: Playback ID. (required)
        :type playback_id: str
        :param media: Media URIs to play. (required)
        :type media: List[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Playback
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the play_with_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.play_with_id_with_http_info(bridge_id, playback_id, media, lang, offsetms, skipms, **kwargs)  # noqa: E501

    @validate_arguments
    async def play_with_id_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], playback_id : Annotated[StrictStr, Field(..., description="Playback ID.")], media : Annotated[conlist(StrictStr), Field(..., description="Media URIs to play.")], lang : Annotated[Optional[StrictStr], Field(description="For sounds, selects language for sound.")] = None, offsetms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.")] = None, skipms : Annotated[Optional[StrictInt], Field(description="Number of milliseconds to skip for forward/reverse operations.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Start playback of media on a bridge.  # noqa: E501

        The media URI may be any of a number of URI's. Currently sound:, recording:, number:, digits:, characters:, and tone: URI's are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)  # noqa: E501

        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param playback_id: Playback ID. (required)
        :type playback_id: str
        :param media: Media URIs to play. (required)
        :type media: List[str]
        :param lang: For sounds, selects language for sound.
        :type lang: str
        :param offsetms: Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
        :type offsetms: int
        :param skipms: Number of milliseconds to skip for forward/reverse operations.
        :type skipms: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Playback, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'bridge_id',
            'playback_id',
            'media',
            'lang',
            'offsetms',
            'skipms'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method play_with_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']

        if _params['playback_id'] is not None:
            _path_params['playbackId'] = _params['playback_id']


        # process the query parameters
        _query_params = []
        if _params.get('media') is not None:  # noqa: E501
            _query_params.append(('media', _params['media']))
            _collection_formats['media'] = 'csv'

        if _params.get('lang') is not None:  # noqa: E501
            _query_params.append(('lang', _params['lang']))

        if _params.get('offsetms') is not None:  # noqa: E501
            _query_params.append(('offsetms', _params['offsetms']))

        if _params.get('skipms') is not None:  # noqa: E501
            _query_params.append(('skipms', _params['skipms']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Playback",
        }

        return await self.api_client.call_api(
            '/bridges/{bridgeId}/play/{playbackId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def record(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], name : Annotated[StrictStr, Field(..., description="Recording's filename")], format : Annotated[StrictStr, Field(..., description="Format to encode audio in")], max_duration_seconds : Annotated[Optional[StrictInt], Field(description="Maximum duration of the recording, in seconds. 0 for no limit.")] = None, max_silence_seconds : Annotated[Optional[StrictInt], Field(description="Maximum duration of silence, in seconds. 0 for no limit.")] = None, if_exists : Annotated[Optional[StrictStr], Field(description="Action to take if a recording with the same name already exists.")] = None, beep : Annotated[Optional[StrictBool], Field(description="Play beep when recording begins")] = None, terminate_on : Annotated[Optional[StrictStr], Field(description="DTMF input to terminate recording.")] = None, **kwargs) -> LiveRecording:  # noqa: E501
        """Start a recording.  # noqa: E501

        This records the mixed audio from all channels participating in this bridge.  # noqa: E501

        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param name: Recording's filename (required)
        :type name: str
        :param format: Format to encode audio in (required)
        :type format: str
        :param max_duration_seconds: Maximum duration of the recording, in seconds. 0 for no limit.
        :type max_duration_seconds: int
        :param max_silence_seconds: Maximum duration of silence, in seconds. 0 for no limit.
        :type max_silence_seconds: int
        :param if_exists: Action to take if a recording with the same name already exists.
        :type if_exists: str
        :param beep: Play beep when recording begins
        :type beep: bool
        :param terminate_on: DTMF input to terminate recording.
        :type terminate_on: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LiveRecording
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the record_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.record_with_http_info(bridge_id, name, format, max_duration_seconds, max_silence_seconds, if_exists, beep, terminate_on, **kwargs)  # noqa: E501

    @validate_arguments
    async def record_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], name : Annotated[StrictStr, Field(..., description="Recording's filename")], format : Annotated[StrictStr, Field(..., description="Format to encode audio in")], max_duration_seconds : Annotated[Optional[StrictInt], Field(description="Maximum duration of the recording, in seconds. 0 for no limit.")] = None, max_silence_seconds : Annotated[Optional[StrictInt], Field(description="Maximum duration of silence, in seconds. 0 for no limit.")] = None, if_exists : Annotated[Optional[StrictStr], Field(description="Action to take if a recording with the same name already exists.")] = None, beep : Annotated[Optional[StrictBool], Field(description="Play beep when recording begins")] = None, terminate_on : Annotated[Optional[StrictStr], Field(description="DTMF input to terminate recording.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Start a recording.  # noqa: E501

        This records the mixed audio from all channels participating in this bridge.  # noqa: E501

        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param name: Recording's filename (required)
        :type name: str
        :param format: Format to encode audio in (required)
        :type format: str
        :param max_duration_seconds: Maximum duration of the recording, in seconds. 0 for no limit.
        :type max_duration_seconds: int
        :param max_silence_seconds: Maximum duration of silence, in seconds. 0 for no limit.
        :type max_silence_seconds: int
        :param if_exists: Action to take if a recording with the same name already exists.
        :type if_exists: str
        :param beep: Play beep when recording begins
        :type beep: bool
        :param terminate_on: DTMF input to terminate recording.
        :type terminate_on: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LiveRecording, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'bridge_id',
            'name',
            'format',
            'max_duration_seconds',
            'max_silence_seconds',
            'if_exists',
            'beep',
            'terminate_on'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method record" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']


        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        if _params.get('max_duration_seconds') is not None:  # noqa: E501
            _query_params.append(('maxDurationSeconds', _params['max_duration_seconds']))

        if _params.get('max_silence_seconds') is not None:  # noqa: E501
            _query_params.append(('maxSilenceSeconds', _params['max_silence_seconds']))

        if _params.get('if_exists') is not None:  # noqa: E501
            _query_params.append(('ifExists', _params['if_exists']))

        if _params.get('beep') is not None:  # noqa: E501
            _query_params.append(('beep', _params['beep']))

        if _params.get('terminate_on') is not None:  # noqa: E501
            _query_params.append(('terminateOn', _params['terminate_on']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "LiveRecording",
        }

        return await self.api_client.call_api(
            '/bridges/{bridgeId}/record', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def remove_channel(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], channel : Annotated[conlist(StrictStr), Field(..., description="Ids of channels to remove from bridge")], **kwargs) -> None:  # noqa: E501
        """Remove a channel from a bridge.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param channel: Ids of channels to remove from bridge (required)
        :type channel: List[str]
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the remove_channel_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.remove_channel_with_http_info(bridge_id, channel, **kwargs)  # noqa: E501

    @validate_arguments
    async def remove_channel_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], channel : Annotated[conlist(StrictStr), Field(..., description="Ids of channels to remove from bridge")], **kwargs) -> ApiResponse:  # noqa: E501
        """Remove a channel from a bridge.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param channel: Ids of channels to remove from bridge (required)
        :type channel: List[str]
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'bridge_id',
            'channel'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_channel" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']


        # process the query parameters
        _query_params = []
        if _params.get('channel') is not None:  # noqa: E501
            _query_params.append(('channel', _params['channel']))
            _collection_formats['channel'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/bridges/{bridgeId}/removeChannel', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def set_video_source(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> None:  # noqa: E501
        """Set a channel as the video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the set_video_source_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.set_video_source_with_http_info(bridge_id, channel_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def set_video_source_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], channel_id : Annotated[StrictStr, Field(..., description="Channel's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Set a channel as the video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param channel_id: Channel's id (required)
        :type channel_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'bridge_id',
            'channel_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_video_source" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']

        if _params['channel_id'] is not None:
            _path_params['channelId'] = _params['channel_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/bridges/{bridgeId}/videoSource/{channelId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def start_moh(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], moh_class : Annotated[Optional[StrictStr], Field(description="Channel's id")] = None, **kwargs) -> None:  # noqa: E501
        """Play music on hold to a bridge or change the MOH class that is playing.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param moh_class: Channel's id
        :type moh_class: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the start_moh_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.start_moh_with_http_info(bridge_id, moh_class, **kwargs)  # noqa: E501

    @validate_arguments
    async def start_moh_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], moh_class : Annotated[Optional[StrictStr], Field(description="Channel's id")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Play music on hold to a bridge or change the MOH class that is playing.  # noqa: E501


        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param moh_class: Channel's id
        :type moh_class: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'bridge_id',
            'moh_class'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_moh" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']


        # process the query parameters
        _query_params = []
        if _params.get('moh_class') is not None:  # noqa: E501
            _query_params.append(('mohClass', _params['moh_class']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/bridges/{bridgeId}/moh', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    async def stop_moh(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], **kwargs) -> None:  # noqa: E501
        """Stop playing music on hold to a bridge.  # noqa: E501

        This will only stop music on hold being played via POST bridges/{bridgeId}/moh.  # noqa: E501

        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the stop_moh_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.stop_moh_with_http_info(bridge_id, **kwargs)  # noqa: E501

    @validate_arguments
    async def stop_moh_with_http_info(self, bridge_id : Annotated[StrictStr, Field(..., description="Bridge's id")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stop playing music on hold to a bridge.  # noqa: E501

        This will only stop music on hold being played via POST bridges/{bridgeId}/moh.  # noqa: E501

        :param bridge_id: Bridge's id (required)
        :type bridge_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'bridge_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_moh" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bridge_id'] is not None:
            _path_params['bridgeId'] = _params['bridge_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            '/bridges/{bridgeId}/moh', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
